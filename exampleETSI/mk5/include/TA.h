#pragma once
/**
 * @addtogroup ta_api Threat Arbitrator (TA) API
 * @{
 *
 * The Cohda Threat Arbitrator is used to detect and warn drivers about the
 * following V2V applications:
 *
 * - Forward Collision Warning (FCW)
 * - Emergency Electronic Brake Light (EEBL)
 * - Intersection Collision Warning (ICW) / Intersection Movement Assist
 *   (IMA) Warning.
 *
 * The Cohda TA uses a callback mechanism to notify of alerts
 *
 * @file
 *
 */

//------------------------------------------------------------------------------
// Copyright (c) 2013 Cohda Wireless Pty Ltd
//------------------------------------------------------------------------------

#ifndef __TA_H_
#define __TA_H_

//------------------------------------------------------------------------------
// Included headers
//------------------------------------------------------------------------------

/// Autogenerated header file containing TA error code enumeration
#include "TA_Err.h"

#include "TC.h"
#include "BufferQueue.h"
#include "Vector.h"
#include "default_stack_defn.h"
#include "lph.h"
#include "vstate.h"

#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif

//------------------------------------------------------------------------------
// Macros & Constants
//------------------------------------------------------------------------------

#define MAX_REFERENCE_DENMS               8
#define TA_ALERT_MAX_IVS_SIGNS            4
#define TA_ALERT_IVS_TEXT_LEN            64
#define TA_ALERT_MAX_IHW                  4

//------------------------------------------------------------------------------
// Type definitions
//------------------------------------------------------------------------------

/// Threat Zones, in HDUS, mapped to front,left,right,rear warnings
typedef struct SafetyZone
{
  int16_t SouthWest;
  int16_t NorthWest;
  int16_t NorthEast;
  int16_t SouthEast;
} tSafetyZone;

typedef struct TAParamsFast
{
  float CurveSep_mm;
  float SafeSpeed_MMPNMIN;
  float SineParallelLimit;
  tSafetyZone SafetyZone;

  float SOFTBRAKE_RAIN_mmpnm2;
  float HARDBRAKE_RAIN_mmpnm2;
  float SOFTBRAKE_SNOW_mmpnm2;
  float HARDBRAKE_SNOW_mmpnm2;
  float SOFTBRAKE_DRY_mmpnm2;
  float HARDBRAKE_DRY_mmpnm2;

  float LON_ACCEL_COEFF_NOW;
  float LON_ACCEL_COEFF_OLD;

  float Hysteresis_DTE_mm;
  float Hysteresis_TTE_ms;

  struct timeval tooOld;
  struct timeval tooYoung;
} tTAParamsFast;

typedef struct TAParams
{
  /// Parameters as read from the conf file
  tdefault_stack_Cohda_TA Raw;
  /// Parameters converted to speed up processing
  tTAParamsFast Fast;
} tTAParams;

typedef struct TAStats
{
  /// TC interfacing
  unsigned NbrTCAdd;
  unsigned NbrTCUpdate;
  unsigned NbrTCPurge;
  unsigned NbrTCConf;
  /// Threat Evaluation
  unsigned NEVALMissingLocal;
  unsigned NEVALAssessments;
  unsigned NEVALNoClassifications;
  unsigned NEVALLocalSlow;
  unsigned NEVALSanityCheckRange;
  unsigned NEVALOperatingRange;
  unsigned NEVALOppositeHeading;
  unsigned NEVALCurveLane;
  unsigned NEVALStraightLane;
  unsigned NEVALRemoteSlow;
  unsigned NEVALCrossingBehind;
  unsigned NEVALFuture;
  unsigned NEVALBehind;
  unsigned NEVALWarnSoft;
  unsigned NEVALWarnHard;
  unsigned NEVALWarnSevere;
} tTAStats;

typedef enum
{
  TA_SIGCOLOR_OFF,
  TA_SIGCOLOR_GREEN,
  TA_SIGCOLOR_YELLOW,
  TA_SIGCOLOR_RED,
} eTALightColorState;

typedef enum
{
  TA_GLOSA_TIME_CHANGE,
  TA_GLOSA_ADV_SPEED,
} eTAGlosaType;

typedef enum
{
  TA_TRAFFIC_DIR_STRAIGHT = 0,
  TA_TRAFFIC_DIR_LEFT,
  TA_TRAFFIC_DIR_RIGHT,
  TA_TRAFFIC_DIR_BALL
} eTALaneDirection;

typedef enum
{
  CSW_DIRECTION_UNKNOWN = 0,
  CSW_DIRECTION_LEFT,
  CSW_DIRECTION_RIGHT
} eCSWDirection;

/// TA severity level
typedef enum TASeverity
{
  /// Magic value used to cancel alerts
  TA_SEVERITY_CANCEL   =   0,
  /// Minimum valid severity, used for tracking
  TA_SEVERITY_MINIMUM  =   1,
  /// Highest severity for tracking
  TA_SEVERITY_TRACKING =  50,
  /// Inform driver, safe to ignore (in-vehicle signage)
  TA_SEVERITY_INFORM   = 100,
  /// Notify driver, should take heed
  TA_SEVERITY_NOTIFY   = 150,
  /// Action required to avoid crash (e.g. braking)
  TA_SEVERITY_WARN     = 200,
  /// Emergency action required to avoid crash (e.g. hard brake)
  TA_SEVERITY_ACTION   = 250,
  /// Crash inevitable, try to mitigate
  TA_SEVERITY_MITIGATE = 255,
} eTASeverity;

/// @ref TASeverity;
typedef uint8_t tTASeverity;

/// Please keep @ref TA_ThreatType() aligned with this
typedef enum TAThreatType
{
  TA_THREATTYPE_NONE       = UINT32_C(0),       ///< No alert
  TA_THREATTYPE_RESERVED0  = (UINT32_C(1)<<0),  ///< Reserved (potentially for future use?)
  // V2V EU + NA
  TA_THREATTYPE_FCW        = (UINT32_C(1)<<1),  ///< Forward Collision Warning
  TA_THREATTYPE_ICW        = (UINT32_C(1)<<2),  ///< Intersection Collision Warning
  TA_THREATTYPE_LTA        = (UINT32_C(1)<<3),  ///< Left Turn Assist
  TA_THREATTYPE_BSW_LCW    = (UINT32_C(1)<<4),  ///< Blind-Spot & Lane-Change Warning (also Motorcycle Approaching Warning)
  TA_THREATTYPE_DNPW       = (UINT32_C(1)<<5),  ///< Do not pass warning
  TA_THREATTYPE_IASS       = (UINT32_C(7)<<6),  ///< Intervention of Active Safety Systems
  TA_THREATTYPE_EEBL       = (UINT32_C(1)<<6),  ///< Emergency Electronic Brake Light
  TA_THREATTYPE_AEB        = (UINT32_C(1)<<7),  ///< Automatic Emergency Braking
  TA_THREATTYPE_PCS        = (UINT32_C(1)<<8),  ///< Pre-Crash Systems
  TA_THREATTYPE_HLW        = (UINT32_C(7)<<9),  ///< Hazard location warning
  TA_THREATTYPE_HLW_FOG    = (UINT32_C(1)<<9),  ///< Hazard location warning - Fog/low visibility
  TA_THREATTYPE_HLW_RAIN   = (UINT32_C(1)<<10), ///< Hazard location warning - Rain/Snow
  TA_THREATTYPE_HLW_TRC    = (UINT32_C(1)<<11), ///< Hazard location warning - Low Traction
  TA_THREATTYPE_SVA        = (UINT32_C(7)<<12), ///< Stationary Vehicles Ahead
  TA_THREATTYPE_SVA_AIR    = (UINT32_C(1)<<12), ///< Stationary Vehicles Ahead - Airbag Deployed
  TA_THREATTYPE_SVA_HZR    = (UINT32_C(1)<<13), ///< Stationary Vehicles Ahead - Hazard Lights
  TA_THREATTYPE_SVA_BRK    = (UINT32_C(1)<<14), ///< Stationary Vehicles Ahead - Broken Down
  TA_THREATTYPE_EVW        = (UINT32_C(1)<<15), ///< Emergency Vehicle Warning
  TA_THREATTYPE_EVW_STAT   = (UINT32_C(1)<<16), ///< Emergency Vehicle Warning - Stationary
  TA_THREATTYPE_VTRW       = (UINT32_C(1)<<17), ///< Vehicle Turning Right in Front of Bus Warning (VTRW)

  // V2I (SPAT/MAP)
  TA_THREATTYPE_GLOSA      = (UINT32_C(1)<<18), ///< Green Light Speed Advice
  TA_THREATTYPE_SVW        = (UINT32_C(1)<<19), ///< Signal Violation Warning
  // V2I (SSM/SRM)
  TA_THREATTYPE_SSM_SRM    = (UINT32_C(1)<<20), ///< SSM/SRM

  // EU DENM
  TA_THREATTYPE_IHW        = (UINT32_C(1)<<21), ///< Infrastructure HLW
  TA_THREATTYPE_IVS        = (UINT32_C(1)<<22), ///< In Vehicle Signage
  TA_THREATTYPE_RWW        = (UINT32_C(1)<<23), ///< Roadwork Warning
  TA_THREATTYPE_TJA        = (UINT32_C(1)<<24), ///< Traffic Jam Ahead

  // V2I (NA TIM & RSA)
  TA_THREATTYPE_RSA        = (UINT32_C(1)<<21), ///< Road Side Alert
  TA_THREATTYPE_CSW        = (UINT32_C(1)<<22), ///< Curve Speed Warning
  TA_THREATTYPE_WZA        = (UINT32_C(1)<<23), ///< Work Zone Alert
  TA_THREATTYPE_OVW        = (UINT32_C(1)<<27), ///< Oversize Vehicle Warning
  TA_THREATTYPE_EVAC       = (UINT32_C(1)<<28), ///< Evacuation
  TA_THREATTYPE_SPEEDLIMIT = (UINT32_C(1)<<29), ///< Speed Limit Warning
  TA_THREATTYPE_GENERICTIM = (UINT32_C(1)<<30), ///< Generic TIM ITIS code matching

  // V2I (CN)
  TA_THREATTYPE_HLW_CN     = (UINT32_C(3)<<21), ///< Hazard location warning
  TA_THREATTYPE_IVS_CN     = (UINT32_C(3)<<22), ///< In Vehicle Signage
  TA_THREATTYPE_TJW_CN     = (UINT32_C(3)<<23), ///< Traffic Jam Warning
  TA_THREATTYPE_VRUSW_CN   = (UINT32_C(3)<<24), ///< Vulnerable Road User Warning CN
  TA_THREATTYPE_SLW        = (UINT32_C(3)<<25), ///< Speed Limit Warning

  // Customer specific
  TA_THREATTYPE_FDW        = (UINT32_C(1)<<21), ///< Forward Distance Warning
  TA_THREATTYPE_FSP        = (UINT32_C(1)<<22), ///< Freight Signaling Priority messages (request, grant, deny)
  TA_THREATTYPE_FCA        = (UINT32_C(1)<<23), ///< Fault Checking Application
  TA_THREATTYPE_UAVD       = (UINT32_C(1)<<24), ///< DSRC vehicle detected (Authorised/Unauthorised)?
  TA_THREATTYPE_DETECTOR   = (UINT32_C(1)<<25), ///< DSRC vehicle detected (Virtual Actuation)
  TA_THREATTYPE_VRU        = (UINT32_C(3)<<26), ///< Vulnerable Road User Warning

  // Customer defined
  TA_THREATTYPE_CUSTOM0    = (UINT32_C(1)<<30), ///< Custom alert type 0
  TA_THREATTYPE_CUSTOM1    = (UINT32_C(1)<<31), ///< Custom alert type 1
} tTAThreatType;

/// Bit-mask of above threat flags. Make sure they all fit!
/// @ref TAThreatType
typedef uint32_t tTAThreatTypes;

/// Additional information to keep with Remote data.
/// The intention is that third-party TA's can maintain housekeeping data
/// which will be managed by the TC.
typedef struct TARemote
{
  /// Maximum threat level posed by this remote.
  uint8_t Level;
  /// Threats this remote is currently posing.
  tTAThreatTypes Threats;
  /// Previous alerts, and flag if the latest evaluation caused a delta
  tTAThreatType PrevTAThreats;
  bool AlertDelta;
  /// Previous control flags, and if the latest evaluation caused a delta
  tTCControlFlags  PrevTCControlFlags;
  bool ControlDelta;
  /// Filtered longitudinal acceleration
  float FiltLonAccel_mmpnmin2;
  ///
  struct timeval LastBrakeOff;
  // Scratchpad for apps.
  size_t ScratchpadSize;
  uint8_t Scratchpad[0];
} tTARemote;


/// per-sign information for in-vehicla-signage alerts
/// memset(-1) to inidcate "unused"
typedef struct TAAlert_IVS_Sign
{
  /// EventDirection.  0 = Ahead, 1 = Behind.
  int8_t IVSDirection;
  /// Distance to the IVS event position. -1 if unknown
  int32_t Distance2IVS_mm; // strictly per zone rather than per sign...
  /// Distance to the end of the IVS.  -1 if unknown
  int32_t Distance2EndIVS_mm;


  /// @note Please refer  http://standards.iso.org/iso/ts/14823/ for these codes
  /// 11 Warning, 12 Regulatory, 13 Guide, 21 Pub Facilities, 3x Ambient or Road Conditions
  /// first digit is ITSISO14823Code_4_choice
  /// second digit is one of ITSISO14823Code_1, ITSISO14823Code_2,  ITSISO14823Code_3
  /// (+1, 1-based rather than 0-based)
  uint8_t ServiceCategory;
  /// first digit is 'nature' field of ITSISO14823Code_5
  /// last 2 digits are 'serialNumber' field of ITSISO14823Code_5
  uint16_t PictogramCategory;

  /// Additional Data, e.g. speed limit value.
  int     Value;
  /// units of above value, ITSRSCUnit
  uint8_t Unit;

  /// Applicable Lanes
  uint16_t ApplicableLanes;

  /// Applicable Lanes Count
  uint8_t ApplicableLanesCount;
  /// Applicable Lanes List
  uint8_t ApplLanesList[8];

  /// ExtraText
  char ExtraText[TA_ALERT_IVS_TEXT_LEN];
} tTAAlert_IVS_Sign;


typedef struct TAAlert_IHW
{
  // ID of the DENM that generated this alert
  uint64_t ID;

  /// Distance to the IHW event position. -1 if unknown
  int32_t Distance2IHW_mm;
  /// Distance to the end of the IHW.  -1 if unknown
  int32_t Distance2EndIHW_mm;

  /// uses the ASN.1 codes.
  /// ITSCauseCodeType
  int CauseCode;
  /// ITSSubCauseCodeType
  int SubCauseCode;
} tTAAlert_IHW;

typedef enum TAAlert_WZAType
{
  TA_WZA_NONE = 0,
  TA_WZA_WORK_ZONE_AHEAD = 1,
  TA_WZA_WORK_ZONE_AHEAD_REDUCE_SPEED = 2,
  TA_WZA_EXCESSIVE_SPEED = 3,
} tTAAlert_WZAType;

/// HV information in Alert
typedef struct TAAlert_HV
{
  /// Position/Speed/Heading/Acceleration/Radius
  tVector Vector;
} tTAAlert_HV;

/// RV information in Alert
typedef struct TAAlert_RV
{
  /// Position/Speed/Heading/Acceleration/Radius
  tVector Vector;
  /// Classification intended to quickly discard irrelevant remotes.
  /// see @ref TA_Eligible
  tTCClassif Classification;
} tTAAlert_RV;

// Structure for notifying of threats via callback
typedef struct TAAlert
{
  /// The packet that caused this alert to be raised (i.e. the one that
  /// needs to be cryptographically verified befor the HMI is notified)
  tExtMessage *pLastOTA;
  /// The last packet with a full cert (may be the same as pLastOTA)
  tExtMessage *pLastCert;

  /// Keep relative bearing for later potential alert
  tHDU  Azimuth;

  /// HV snapshot when a V2V or V2I alert is reported
  tTAAlert_HV HV;
  /// RV snapshot when a V2V alert is reported
  tTAAlert_RV RV;

  /** Alert ID. See @ref fTA_ThreatApplication and
   *  @ref fTA_NonRVThreatApplication for how to set it up
   */
  uint64_t ID;
  /// Type of threat. Set by registered TA Applications
  tTAThreatType Type;
  /// Threat Severity Level. Set by registered TA Applications
  /// @see TASeverity
  tTASeverity Level;
  /// Time to event in seconds (if known/relevant, or NAN if unknown/irrelevant).
  /// Set by registered TA Applications
  float TimeToEvent_s;
  /// Distance to event in meters (if known/relevant, or NAN if unknown/irrelevant).
  /// Set by registered TA Applications
  float DistanceToEvent_m;

  /// Alert-specific data. Set by registered TA Applications
  union
  {
    /// Emergency Electronic Brake Light
    /// Type == TA_THREATTYPE_EEBL
    struct
    {
      /// eEEBLLevel (light/medium/heavy)
      int Level;
    } EEBL;
    /// Type == TA_THREATTYPE_IHW
    struct
    {
      uint8_t AlertCount;
      tTAAlert_IHW Alerts[TA_ALERT_MAX_IHW];
    } IHW;
    /// Type == TA_THREATTYPE_HLW_TRC
    struct
    {
      /// HLW_TRC Scenario type. Set by HLW App
      enum {
        TA_HLW_TRC_SCENARIO_NONE = 0x0,
        /// Antilock-breaking active
        TA_HLW_TRC_SCENARIO_ABS  = 0x1,
        /// Traction-control active
        TA_HLW_TRC_SCENARIO_TRC  = 0x2,
        /// Stability-control active
        TA_HLW_TRC_SCENARIO_SCA  = 0x4,
      } Scenario;
    } HLW_TRC;
    /// Forward Collision Warning
    /// Type == TA_THREATTYPE_FCW
    struct
    {
      // Placeholder for future data.
      // non-empty to keep static code analysis tools happy.
      char dummy_to_keep_vs_happy;
    } FCW;
    /// Forward Distance Warning
    /// Type == TA_THREATTYPE_FDW
    struct
    {
      char dummy_to_keep_vs_happy;
    } FDW;
    /// Emergency Vehicle Warning
    /// Type == TA_THREATTYPE_EVW
    struct
    {
      char dummy_to_keep_vs_happy;
    } EVW;
    /// Fault Checking Application
    /// Type == TA_THREATTYPE_FCA
    struct
    {
      char dummy_to_keep_vs_happy;
    } FCA;
    /// Type == TA_THREATTYPE_UAVD
    struct
    {
      uint16_t VehCertID; ///CertID of the authorised vehicle (Upper 16bit information)
    } UAVD;
    /// Intersection Collision Warning
    /// Type == TA_THREATTYPE_ICW
    struct
    {
      /// ICW Scenario type. Set by ICW App
      enum {
        TA_ICW_SCENARIO_ICW, ///< RV Intersection Collision Warning
        TA_ICW_SCENARIO_IMA  ///< HV Creeping and Entering
      } Scenario;

      /// Bearing or RV rw.r.t. HV
      tHDU ThreatBearing;
      tSafetyZone SafetyZone;
    } ICW;
    /// Type == TA_THREATTYPE_LTA
    struct
    {
      char dummy_to_keep_vs_happy;
    } LTA;
    /// Type == TA_THREATTYPE_BSW_LCW
    struct
    {
      /// BSW_LCW Scenario type. Set by BSW_LCW App
      enum {
        TA_BSW_LCW_SCENARIO_BSW,
        TA_BSW_LCW_SCENARIO_LCW
      } Scenario;
    } BSW_LCW;
    /// Curve Speed Warning
    /// Type == TA_THREATTYPE_CSW
    struct
    {
      /// Direction of CSW (left/right) - see ITIS code
      uint16_t AlertDirection;
      /// Speed Limit (km/h)
      uint16_t SpeedLimit;
      /// Region of the Vehicle in the CSW path
      uint8_t Region;
    } CSW;
    /// Speed Limit Warning
    /// Type == TA_THREATTYPE_SPEEDLIMIT
    struct
    {
      /// Speed Limit (km/h)
      uint16_t SpeedLimit;
      /// Region of the Vehicle in the Speed Limit path
      uint8_t Region;
    } SpeedLimit;
    /// Generic TIM ITIS code match
    /// Type == TA_THREATTYPE_GENERICTIM
    struct
    {
      /// ITISCode
      int ITISCode;
    } GenericTIM;
    /// Road Work Warning
    /// Type == TA_THREATTYPE_RWW
    struct
    {
      /// ActionID of the RWW DENM (i.e. StationID + Sequence Number)
      uint64_t EventId;
      /// Time of the RWW alert - UTC epoch with millisecond precision
      uint64_t AlertTime_ms;
      /// EventDirection w.r.t HV: 0 = Ahead (HV approaching event), 1 = Behind (HV in event)
      int8_t RWWDirection;
      /// Distance to the RWW event position (i.e. start of event). -1 if unknown
      int32_t Distance2RWW_mm;
      /// Distance to the end of the RWW.  -1 if unknown
      int32_t Distance2EndRWW_mm;
      /// Is the RWW mobile (moving). -1 if unknown, 0 = known stationary, 1 = known moving
      int8_t IsMobile;
      /// Is the RWW winter service. -1 if unknown, 0 = not winder, 1 = winter
      int8_t IsWinter;
      /// Outer Hard shoulder status. -1 if unknown, 0 = no shoulder, 1 = shoulder
      int8_t OuterHardShoulderStatus;
      /// Inner Hard shoulder status. -1 if unknown, 0 = no shoulder, 1 = shoulder
      int8_t InnerHardShoulderStatus;
      /// Number of Lanes. -1 if unknown
      int8_t NumberOfLanes;
      /// Closed Lanes (bitwise indication). -1 if unknown
      int16_t ClosedLanes;
      /// Is the Speed Limit Applicable
      uint8_t SpeedLimitApplicable;
      /// SpeedLimit (km/h). -1 if unknown
      int16_t SpeedLimit_kmph;
      /// TrafficFlowRule. -1 if unknown
      int8_t TrafficFlowRule;
      /// Reference events - related RWW event Action IDs (see "EventId" above).
      uint64_t ReferenceEvents[MAX_REFERENCE_DENMS];
    } RWW;
    /// Speed Limit Warning (SLW)
    /// Type == TA_THREATTYPE_SLW
    struct
    {
      /// Lane id, ID from MAP
      int LaneId;
      /// Current HV speed
      float CurSpeed_mps;
      /// Max Speed Limit
      float MaxSpeedLimit_mps;
      /// Over Speed?
      bool OverSpeed;
    } SLW;
    /// Green Light Optimized Speed Advise (SLW)
    /// Type == TA_THREATTYPE_GLOSA
    struct
    {
      /// Current type of GLOSA @ref eTAGlosaType
      uint8_t AlertType;
      /// Current signal state @ref eTALightColorState
      uint8_t CurrentPhase;
      /// Signal state upon vehicle arrival @ref eTALightColorState
      uint8_t PhaseAtArrival;
      /// Direction to which this phase applies @ref eTALaneDirection
      uint8_t ValidDirection;
      /// (0 Vertical, 1 Horizontal)
      uint8_t Mounting;
      /// Turn warning
      bool CrossingWarn;
      /// Time to current signal change (1/10'th seconds)
      int TimeChange_ds;
      /// Lane id, ID from MAP of intersection
      int LaneId;
      /// Stop line latitude (deg)
      double StopLineLat_deg;
      /// Stop line longitude (deg)
      double StopLineLon_deg;

      /// Current HV speed
      float CurSpeed_mps;
      /// Calculated advised speed, (m/s)
      float AdvSpeed_mps;
      /// Calculated advised acceleration (m/s^2)
      float AdvAccel_mps2;
    } GLOSA;
    /// Signal Violation Warning (SVW)
    /// Type == TA_THREATTYPE_SVW
    struct
    {
      /// Current signal state @ref eTALightColorState
      uint8_t CurrentPhase;
      /// Signal state upon vehicle arrival @ref eTALightColorState
      uint8_t PhaseAtArrival;
      /// Direction to which this phase applies @ref eTALaneDirection
      uint8_t ValidDirection;
      /// Time to current signal change (1/10'th seconds)
      int TimeChange_ds;
      /// Lane id, ID from MAP of intersection
      int LaneId;
      /// Stop line latitude (deg)
      double StopLineLat_deg;
      /// Stop line longitude (deg)
      double StopLineLon_deg;
    } SVW;
    /// In Vehicle Signage
    /// Type == TA_THREATTYPE_IVS
    struct
    {
      /// ID of the IVS station
      uint32_t StationId;
      /// Time of the IVS alert - UTC
      uint64_t ReferenceTime_ms;
      /// Sign Country Code. From iso14823
      uint8_t CountryCode[2];

      /// signs
      tTAAlert_IVS_Sign Signs[TA_ALERT_MAX_IVS_SIGNS];
      char Text[TA_ALERT_IVS_TEXT_LEN];
    } IVS;
    /// Vulnerable Road User Collision Warning
    /// Type == TA_THREATTYPE_VRUSW
    struct
    {
      /// ITISCode
      int EventTypeITIS;
    } VRUSW;
    /// Road Side Alert
    /// Type == TA_THREATTYPE_RSA
    struct
    {
      /// ITISCode
      int EventTypeITIS;
    } RSA;
    /// Hazard Location Warning
    /// Type == TA_THREATTYPE_HLW_CN
    struct
    {
      /// GB/T 29100
      int EventType;
      /// On the path or inside the radius. See @ref RSICNPointInRegionResult
      uint8_t Region;
    } HLW_CN;
    /// Traffic Jam Warning
    /// Type == TA_THREATTYPE_TJW_CN
    struct
    {
      /// GB/T 29100
      int EventType;
      /// On the path or inside the radius. See @ref RSICNPointInRegionResult
      uint8_t Region;
    } TJW_CN;
    struct
    {
      /// GB 5768.2-2009
      int SignType;
    } IVS_CN;
    /// Work Zone Alert
    /// Type == TA_THREATTYPE_WZA
    struct
    {
      /// Type of Work Zone Alert
      tTAAlert_WZAType WZAType;
      /// Speed Limit (kilometres per hour)
      uint16_t SpeedLimit_kph;
    } WZA;
    /// Oversize Vehicle Warning
    /// Type == TA_THREATTYPE_OVW
    struct
    {
      float ClearanceHeight_m;
      float DistanceToCrash_m;
    } OVW;
    /// Evacuation
    /// Type == TA_THREATTYPE_EVAC
    struct
    {
      /// ITISCode
      int EventTypeITIS;
    } EVAC;
    /// Type == TA_THREATTYPE_VTRW
    struct
    {
      tTCClassif Classification;
      char dummy_to_keep_vs_happy;
    } VTRW;
  };
} tTAAlert;

struct TA;
struct TCRemote;

/// Host Vehicle summary (sometimes known as EGO vehicle).
typedef struct TA_HV
{
  /// Kinematics
  const tVector      *pVector;
  /// Vehicle state
  const tVStateState *pVState;
  /// Path Prediction
  const tLPHPP       *pLPHPP;
  /// Path history
  const tLPHPH       *pLPHPH;
  /// Local position in integer units, useful for ADR
  const tLPHPos      *pLPHPos;
} tTA_HV;

/// Remote Vehicle summary
typedef struct TA_RV
{
  /// remote vehicle Classification
  const struct TCRemote *pTCRemote;
  /// remote vehicle threat assesment
  tTARemote             *pTARemote;
} tTA_RV;

/**
 * @brief Assess an RV
 * This function is provided by the Application to evaluate a given Remote
 * Vehicle for a given threat. The current Host and Remote vehicle information
 * is passed in, as well as an alert to fill in (in case there's an alert) and a
 * copy of the current alert (in case it is no longer relevant and needs to be
 * cancelled).
 *
 * To report an alert, set up Type/Level/TimeToEvent_s/DistanceToEvent_m and alert-specific
 * fields in pAlert. Other fields in pAlert are set up by TA automatically.
 *
 * @param[in] pHV Data for the HV
 * @param[in] pRV Data for the RV under consideration
 * @param[out] pAlert RV alert state (modifed by this func)
 * @param[in] pCurrentAlert Current TA alert state (i.e. what the HMI is currently displaying)
 * @param[in,out] pPriv Provided to TA_RegisterApplication()
 * @param[in,out] pScratchpad Per-remote scratchpad for the registered application
 */
typedef void (fTA_ThreatApplication)(const tTA_HV *pHV,
                                     const tTA_RV *pRV,
                                     tTAAlert *pAlert,
                                     const tTAAlert *pCurrentAlert,
                                     void *pPriv,
                                     void *pScratchpad);

typedef void (fTA_ScratchpadInit)(void *pScratchpad);
typedef void (fTA_ScratchpadDeInit)(void *pScratchpad);


/**
 * @brief Assess a non-RV Threat (RWW, GLOSA etc.)
 *
 * This function is provided by the Application to evaluate a given threat that is
 * independant of Remote Vehicles. See @ref fTA_ThreatApplication.
 *
 * @param[in] pHV Data for the HV
 * @param[out] pAlert RV alert state (modifed by this func)
 * @param[in] pCurrentAlert Current TA alert state (i.e. what the HMI is currently displaying)
 * @param[in,out] pPriv Provided to TA_RegisterApplication()
 */
typedef void (fTA_NonRVThreatApplication)(const tTA_HV *pHV,
                                          tTAAlert *pAlert,
                                          const tTAAlert *pCurrentAlert,
                                          void *pPriv);

/**
 * @brief Handle updated configuration
 * @param[in] pIniFile Parsed configuration data
 * @param[in,out] pPriv Provided to TA_RegisterApplication()
 */
typedef void (fTA_ConfigUpdated)(const tdefault_stack *pIniFile,
                                 void *pPriv);

/// Function prototype for user notification of alerts
/// @note: This function can be called from the EXT thread
/// and simultaneously from the periodic reprocessig thread.
/// It must be reentrant and it must be fast.
typedef void (fTA_Callback) (const tTAAlert *pAlert,
                             void *pData);

/// A function you can call to obtain the current alert
typedef bool (fTA_CurrentAlert)(tTAAlert *pAlert,
                                void *pData);

//------------------------------------------------------------------------------
// Function Prototypes
//------------------------------------------------------------------------------

/**
 * @brief Initialise the TA
 *
 * @param pParams Configuration Parameters
 * @param pAlertCB Callback for alerts
 * @param pAlertCBData user-defined parameter for callback
 * @param pCurrentAlertCB Callback to obtain current alert
 * @param pCurrentAlertCBData Parameter to supply to callback to obtain current alerts
 *
 * @return TA_ERR_NONE or @ref TA_ErrCode if an error occurs
 */
tTA_ErrCode TA_Init(const tdefault_stack_Cohda_TA *pParams,
                    fTA_Callback *pAlertCB,
                    void *pAlertCBData,
                    fTA_CurrentAlert *pCurrentAlertCB,
                    void *pCurrentAlertCBData);

/**
 * @brief Terminate the TA.
 *
 * kill the periodic re-analysis thread, close the TC.
 *
 * @return TA_ERR_NONE or TA_ERR_TC_CLOSE
 */
tTA_ErrCode TA_Exit(void);

/**
 * @brief Return a pointer to the (optionally cleared) stats.
 *
 * @param Reset true to clear stats
 *
 * @return the (optionally cleared) stats
 */
const tTAStats *TA_Stats(bool Reset);

/**
 * @brief Register a threat application
 *
 * @param pFunc Callback function to evaluate the threat
 * @param MaxLevel Maximum threat level this application can return
 * @param pPriv user-defined parameter
 * @param pConf Callback function for configuration updates
 * @param pTag pointer to Thread ID
 * @param pInit Scratchpad init function
 * @param pDeInit Scratchpad de-init function
 * @param ScratchpadSize Scratchpad size
 *
 * Note that there is no lock on the apps table so this should
 * be done before any remotes are reported to avoid race conditions.
 *
 * @return TA_ERR_NONE, TA_ERR_APP_DISABLED or TA_ERR_TOO_MANY_APPS
 */
tTA_ErrCode TA_RegisterApplication(fTA_ThreatApplication *pFunc,
                                   uint8_t MaxLevel,
                                   void *pPriv,
                                   fTA_ConfigUpdated *pConf,
                                   const char *pTag,
                                   fTA_ScratchpadInit *pInit,
                                   fTA_ScratchpadDeInit *pDeInit,
                                   size_t ScratchpadSize);

/**
 * @brief Register a non-RV threat application
 *
 * @param pFunc Callback function to evaluate the threat
 * @param MaxLevel Maximum threat level this application can return
 * @param pPriv user-defined parameter
 * @param pConf Callback function for configuration updates
 * @param pTag pointer to Thread ID
 *
 * Note that there is no lock on the apps table so this should
 * be done before any remotes are reported to avoid race conditions.
 *
 * @return TA_ERR_NONE, TA_ERR_APP_DISABLED or TA_ERR_TOO_MANY_APPS
 */
tTA_ErrCode TA_RegisterNonRVApplication(fTA_NonRVThreatApplication *pFunc,
                                        tTASeverity MaxLevel,
                                        void *pPriv,
                                        fTA_ConfigUpdated *pConf,
                                        const char * pTag);

/**
 * @brief De-register a threat application
 *
 * @param pFunc Callback function registered to evaluate the threat
 * @param MaxLevel Maximum threat level this application can return
 *
 * @return TA_ERR_NONE, TA_ERR_APP_DISABLED
 */
tTA_ErrCode TA_DeregisterApplication(fTA_ThreatApplication *pFunc,
                                     tTASeverity MaxLevel);

/**
 * @brief De-register a non-RV threat application
 *
 * @param pFunc Callback function registered to evaluate the threat
 * @param MaxLevel Maximum threat level this application can return
 *
 * @return TA_ERR_NONE, TA_ERR_APP_DISABLED
 */
tTA_ErrCode TA_DeregisterNonRVApplication(fTA_NonRVThreatApplication *pFunc,
                                          uint8_t MaxLevel);

/**
 * @brief atomic *threats |= mask (i.e. set the bits given in mask)
 *
 * @param pThreats The threats to modify
 * @param Mask The bits to set
 * @param Id Remote ID
 * @param pTag pointer to Thread ID
 */
void TA_SetThreat(tTAThreatTypes *pThreats,
                  tTAThreatTypes Mask,
                  uint64_t Id,
                  const char *pTag);

/**
 * @brief atomic *threats &= ~mask (i.e. clear the bits given in mask)
 *
 * @param pThreats The threats to modify
 * @param Mask The bits to clear
 * @param Id Remote ID
 * @param pTag pointer to Thread ID
 */
void TA_ClearThreat(tTAThreatTypes *pThreats,
                    tTAThreatTypes Mask,
                    uint64_t Id,
                    const char *pTag);

/**
 * @brief Report that alert
 *
 * @param pTAAlert The alert to report
 */
void TA_ReportAlert(const tTAAlert *pTAAlert);

/**
 * @brief Cancel the given alert.
 *
 * @param pTAAlert The alert to cancel.
 */
void TA_CancelAlert(const tTAAlert *pTAAlert);

/**
 * @brief Determine if the cutoff time is active. If not, set the cutoff time
 *
 * @param Now The current time.
 * @param Cutoff The cutoff time to be evaluated/set
 * @param CutoffDuration Timeval from config parameter to add when setting cutoff time

 * @return True if no active cutoff time
 */
bool TA_IsCutoffExpired(const struct timeval *Now,
                        struct timeval *Cutoff,
                        const struct timeval *CutoffDuration);

/**
 * @brief Get a string representing the given threat
 *
 * @param Type The threat to obtain a string for
 *
 * @return an appropriate string (e.g. "EEBL") or "???"
 */
const char *TA_ThreatType(tTAThreatType Type);

/**
 * @brief Return the active TA parameters
 *
 * @return Active parameters
 */
const tTAParams *TA_Params(void);

/**
 * @brief Adjust time and distance to event if there is an active alert
 *
 * @param Alerting True if there is an active alert
 * @param MaxRange_mm Maximum range required to alert
 * @param MaxTime_ms Minimum time required to alert
 */
void TA_AdjustDistanceTime(bool Alerting,
                           float *MaxRange_mm,
                           float *MaxTime_ms);

/**
 * @brief Helper to update distance to event when cancelling alert
 *
 * @param pAlert The alert to be updated
 * @param pCurrentAlert Current alert
 * @param pRv pointer to remote vehicle structure
 *
 */
void TA_UpdateDistForAlertCancellation(tTAAlert *pAlert,
                                       const tTAAlert *pCurrentAlert,
                                       const tTA_RV *pRv);

#ifdef __cplusplus
}
#endif

#endif // __TA_H_

// Close the doxygen group
/**
 * @}
 */
